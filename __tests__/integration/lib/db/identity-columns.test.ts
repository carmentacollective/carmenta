/**
 * Identity Column Insert Tests
 *
 * Tests that Drizzle ORM can insert into tables with PostgreSQL identity columns.
 *
 * Context: We experienced production failures (CARMENTA-5E through CARMENTA-6D)
 * where inserts to tables with GENERATED ALWAYS AS IDENTITY columns failed because
 * Drizzle explicitly passes DEFAULT for identity columns, which PostgreSQL rejects.
 *
 * Solution: Changed all identity columns to GENERATED BY DEFAULT AS IDENTITY, which
 * accepts DEFAULT values. This test verifies the fix works.
 *
 * @see https://github.com/drizzle-team/drizzle-orm/issues/3210
 */

import { describe, it, expect, beforeEach } from "vitest";
import { setupTestDb } from "@/vitest.setup";
import { sql } from "drizzle-orm";

import { db } from "@/lib/db";
import {
    users,
    connections,
    extractionJobs,
    extractionProcessedConnections,
    mcpServers,
    pushSubscriptions,
    featureTipViews,
} from "@/lib/db/schema";

setupTestDb();

describe("Identity Column Inserts", () => {
    let testUserId: string;
    let testUserEmail: string;
    let testConnectionId: number;

    beforeEach(async () => {
        // Create test user
        const [user] = await db
            .insert(users)
            .values({
                email: `test-${Date.now()}@example.com`,
                clerkId: `clerk_test_${Date.now()}`,
            })
            .returning();
        testUserId = user.id;
        testUserEmail = user.email;

        // Create test connection
        const [connection] = await db
            .insert(connections)
            .values({
                userId: testUserId,
                slug: `test-${Date.now()}`,
            })
            .returning();
        testConnectionId = connection.id;
    });

    describe("extractionProcessedConnections", () => {
        it("should insert with auto-generated identity id", async () => {
            // First create an extraction job
            const [job] = await db
                .insert(extractionJobs)
                .values({
                    userId: testUserId,
                    totalConversations: 1,
                })
                .returning();

            // This insert was failing in production with GENERATED ALWAYS AS IDENTITY
            // because Drizzle was passing: values (default, $1, $2, $3, $4, default)
            // and PostgreSQL rejects explicit DEFAULT for GENERATED ALWAYS columns
            const [record] = await db
                .insert(extractionProcessedConnections)
                .values({
                    userId: testUserId,
                    connectionId: testConnectionId,
                    jobId: job.id,
                    extractionCount: 3,
                })
                .returning();

            expect(record.id).toBeGreaterThan(0);
            expect(record.userId).toBe(testUserId);
            expect(record.connectionId).toBe(testConnectionId);
            expect(record.extractionCount).toBe(3);
        });

        it("should handle onConflictDoNothing for retries", async () => {
            const [job] = await db
                .insert(extractionJobs)
                .values({
                    userId: testUserId,
                    totalConversations: 1,
                })
                .returning();

            // First insert
            await db.insert(extractionProcessedConnections).values({
                userId: testUserId,
                connectionId: testConnectionId,
                jobId: job.id,
                extractionCount: 3,
            });

            // Second insert (retry scenario) - should not throw
            const result = await db
                .insert(extractionProcessedConnections)
                .values({
                    userId: testUserId,
                    connectionId: testConnectionId,
                    jobId: job.id,
                    extractionCount: 5, // Different value, but should be ignored
                })
                .onConflictDoNothing()
                .returning();

            // onConflictDoNothing returns empty array when conflict occurs
            expect(result).toHaveLength(0);
        });
    });

    describe("mcpServers", () => {
        it("should insert with auto-generated identity id", async () => {
            const [server] = await db
                .insert(mcpServers)
                .values({
                    userEmail: testUserEmail,
                    identifier: `test-server-${Date.now()}`,
                    displayName: "Test Server",
                    url: "https://mcp.example.com/server",
                    isDefault: false,
                })
                .returning();

            expect(server.id).toBeGreaterThan(0);
            expect(server.identifier).toContain("test-server");
        });
    });

    describe("pushSubscriptions", () => {
        it("should insert with auto-generated identity id", async () => {
            const mockSubscription = {
                endpoint: `https://push.example.com/${Date.now()}`,
                keys: {
                    p256dh: "test-p256dh-key",
                    auth: "test-auth-key",
                },
            };

            const [subscription] = await db
                .insert(pushSubscriptions)
                .values({
                    userEmail: testUserEmail,
                    subscription: mockSubscription,
                    endpoint: mockSubscription.endpoint,
                    userAgent: "Test Browser",
                })
                .returning();

            expect(subscription.id).toBeGreaterThan(0);
            expect(subscription.endpoint).toBe(mockSubscription.endpoint);
        });
    });

    describe("featureTipViews", () => {
        it("should insert with auto-generated identity id", async () => {
            const [view] = await db
                .insert(featureTipViews)
                .values({
                    userId: testUserId,
                    tipId: "test-tip-id",
                    state: "shown",
                    shownCount: 1,
                })
                .returning();

            expect(view.id).toBeGreaterThan(0);
            expect(view.tipId).toBe("test-tip-id");
            expect(view.state).toBe("shown");
        });
    });
});
