---
description: When writing tests for typescript
alwaysApply: false
---

# Testing Standards for TypeScript with Vitest

Test what matters. Focus on behavior and functionality, not implementation details or
configuration. Good tests give confidence that the application works correctly while
remaining maintainable.

## Core Principles

Write tests that validate business logic and user-facing behavior. Test runtime error
handling with invalid inputs, edge cases, and integration between components. Target 90%
line coverage and 85% branch coverage through meaningful tests, not by chasing numbers.

Minimize mocking of your own code. Use real database operations with PGlite for
integration tests. Mock external APIs, third-party services, and non-deterministic
operations, but don't mock your own database layer or business logic. A missing
migration that crashes production should fail your tests.

Write independent, isolated tests. Each test should stand alone without depending on
execution order. Use descriptive names that read like documentation. Follow the AAA
pattern: Arrange (setup), Act (execute), Assert (verify).

## Writing Effective Tests

Here are examples of well-structured tests:

```typescript
// Test successful behavior first
it("processes payment successfully", async () => {
  const payment = { amount: 100, currency: "USD" };
  const mockUser = createMockUser();

  const result = await processPayment(mockUser, payment);

  expect(result.success).toBe(true);
  expect(result.transactionId).toBeDefined();
});

// Test error handling with user input
it("returns 400 for invalid email format", async () => {
  const response = await POST({ email: "not-an-email" });
  expect(response.status).toBe(400);
  expect(response.error).toContain("Invalid field: email");
});

// Test with real database operations
it("creates user with all required fields", async () => {
  await db.insert(schema.users).values({
    email: "test@example.com",
    clerkId: "clerk_123",
    name: "Test User",
  });

  const user = await getUserByEmail("test@example.com");
  expect(user.email).toBe("test@example.com");
});

// Test edge cases and boundaries
it("returns user-friendly error message for invalid email", () => {
  const result = validateEmail("not-an-email");
  expect(result.error).toBe("Please enter a valid email address");
});

// Test integration between components
describe("User Operations", () => {
  it("creates user with generated ID", async () => {
    const user = await createUser({ email: "test@example.com" });
    expect(user.id).toBeDefined();
  });

  it("deletes user by ID", async () => {
    const user = await createUser({ email: "test@example.com" });
    const deleted = await deleteUser(user.id);
    expect(deleted).toBe(true);
  });
});
```

Avoid testing configuration that should be stable in deployment. Don't test environment
variable presence or framework internals. Don't validate that broken systems stay
broken - test that working code continues to work. When testing error handling, verify
the system gracefully handles bad input, not that missing configuration causes errors.

Use `toMatchObject()` for flexible assertions rather than exact equality when you don't
care about every field. This makes tests more maintainable and less brittle.

## Testing with PGlite and Drizzle ORM

Use PGlite (in-memory WASM PostgreSQL) with a single global mock. This is the
industry-standard pattern from Drizzle's official examples. The key insight: mock the
database MODULE (swap Postgres for PGlite), but use real database OPERATIONS
(db.insert(), db.query(), etc.).

### The Critical Rule: One Global Mock, Zero Local Mocks

Local vi.mock() calls in test files OVERRIDE the global PGlite mock. This breaks tests
because local mocks provide incomplete interfaces. When production code calls
`db.query.users.findFirst()` but your local mock only defines `db.user.upsert`, you get
`TypeError: Cannot read properties of undefined (reading 'users')`.

Never create local vi.mock("@/lib/db") calls in test files. The global mock from
vitest.setup.ts provides everything you need.

### Setup in vitest.setup.ts

```typescript
import { PGlite } from "@electric-sql/pglite";
import { drizzle } from "drizzle-orm/pglite";
import { migrate } from "drizzle-orm/pglite/migrator";
import { sql } from "drizzle-orm";
import * as schema from "./lib/db/schema";

const client = new PGlite();
const testDb = drizzle(client, { schema });

// Global mock replaces production db with PGlite
vi.mock("./lib/db", async (importOriginal) => {
  return {
    ...(await importOriginal<typeof import("./lib/db")>()),
    db: testDb,
    schema,
  };
});

// Run migrations before each test
beforeEach(async () => {
  await migrate(testDb, {
    migrationsFolder: path.join(process.cwd(), "drizzle/migrations"),
  });
});

// Clean database between tests (Django-style isolation)
afterEach(async () => {
  await testDb.execute(sql`DROP SCHEMA IF EXISTS public CASCADE`);
  await testDb.execute(sql`CREATE SCHEMA public`);
  await testDb.execute(sql`DROP SCHEMA IF EXISTS drizzle CASCADE`);
});
```

### Using Real Database Operations in Tests

Import the db and schema, then use real database operations. No vi.mocked(), no
mockResolvedValue(). Just insert data, call your code, verify results.

```typescript
import { db, schema } from "@/lib/db";
import { eq } from "drizzle-orm";

it("creates user successfully", async () => {
  // Setup: Insert real data with real database
  await db.insert(schema.users).values({
    email: "test@example.com",
    clerkId: "clerk_123",
    name: "Test User",
  });

  // Act: Call production code (uses real PGlite)
  const user = await getUserByEmail("test@example.com");

  // Assert: Verify real database state
  expect(user.email).toBe("test@example.com");
  expect(user.name).toBe("Test User");
});

it("returns user with their connections", async () => {
  // Setup: Create related data
  const [user] = await db
    .insert(schema.users)
    .values({
      email: "test@example.com",
      clerkId: "clerk_123",
      name: "Test User",
    })
    .returning();

  await db.insert(schema.connections).values({
    userId: user.id,
    service: "github",
    accessToken: "encrypted_token",
    status: "CONNECTED",
  });

  // Act: Production code uses real db.query with relationships
  const result = await db.query.users.findFirst({
    where: eq(schema.users.email, "test@example.com"),
    with: { connections: true },
  });

  // Assert: Real database relationships work
  expect(result?.email).toBe("test@example.com");
  expect(result?.connections).toHaveLength(1);
  expect(result?.connections[0].service).toBe("github");
});
```

### Why This Pattern Works

This validates real behavior. Tests catch missing migrations, wrong schemas, invalid
SQL, and broken relationships. The database cleanup between tests provides isolation
automatically - no manual coordination needed. This matches Drizzle's official examples
and industry best practices.

When production code uses `db.query.users.findFirst()`, tests work automatically because
db.query is real PGlite, not a mock. You can't get partial interface errors because
you're not creating partial interfaces.

### Common Mistakes

Don't use vi.mocked() with database operations - insert real data instead. Don't create
local database mocks in test files - trust the global mock from vitest.setup.ts. Don't
manually clean up specific tables - drop the entire schema (already in vitest.setup.ts).

Pattern based on
[Drizzle's official Vitest + PGlite example](https://github.com/drizzle-team/drizzle-orm/tree/main/examples/vitest-pg).

## Test Fixtures

Create reusable fixture functions in `__tests__/fixtures/` to keep tests DRY:

```typescript
// __tests__/fixtures/db-fixtures.ts
import { db, schema } from "@/lib/db";

export interface TestUserOptions {
  email?: string;
  clerkId?: string;
  name?: string;
}

export async function createTestUser(options: TestUserOptions = {}) {
  const [user] = await db
    .insert(schema.users)
    .values({
      email: options.email ?? "test@example.com",
      clerkId: options.clerkId ?? "clerk_123",
      name: options.name ?? "Test User",
    })
    .returning();
  return user;
}

// Compound fixture for common scenarios
export async function createTestUserWithOAuth() {
  const user = await createTestUser();

  const [client] = await db
    .insert(schema.oauthClients)
    .values({
      userEmail: user.email,
      clientId: "test_client",
      // ... defaults
    })
    .returning();

  const [token] = await db
    .insert(schema.oauthAccessTokens)
    .values({
      userEmail: user.email,
      clientId: client.clientId,
      // ... defaults
    })
    .returning();

  return { user, client, token };
}
```

Usage in tests:

```typescript
import { createTestUserWithOAuth } from "@/__tests__/fixtures/db-fixtures";

describe("MCP Endpoint", () => {
  let user, client, token;

  beforeEach(async () => {
    ({ user, client, token } = await createTestUserWithOAuth());
  });

  it("authenticates with OAuth token", async () => {
    const response = await POST(
      new NextRequest("http://localhost/mcp", {
        headers: { Authorization: `Bearer ${token.accessToken}` },
      })
    );
    expect(response.status).toBe(200);
  });
});
```

Fixtures provide type safety, composability, and explicit imports. Return created
entities from fixtures. Use sensible defaults and allow overrides. Keep fixtures pure
with no side effects beyond database operations.

## Vitest Best Practices

Use concurrent tests for pure functions that don't share state:

```typescript
describe.concurrent("Pure Functions", () => {
  it("calculates total", () => { ... });
  it("formats currency", () => { ... });
});
```

Don't use concurrent for tests that share resources like database state.

Set up fresh state in beforeEach:

```typescript
describe("API Tests", () => {
  let mockUser;

  beforeEach(() => {
    mockUser = {
      id: "test-id",
      email: "test@example.com",
    };
    vi.clearAllMocks();
  });
});
```

Clean up in afterEach:

```typescript
afterEach(() => {
  vi.clearAllMocks();
  vi.restoreAllMocks();
  vi.unstubAllEnvs();
});
```

## Running Tests Correctly

Never pipe test commands - piping creates orphaned worker processes that consume 110%+
CPU indefinitely when interrupted.

Run specific test file:

```bash
pnpm test -- path/to/file.test.ts
pnpm test -- __tests__/unit/lib/adapters/notion.test.ts
```

Filter by test name:

```bash
pnpm test -- -t "pattern"
pnpm test -- -t "should handle errors"
```

Run all tests:

```bash
pnpm test
```

File paths are positional arguments, not flags. Use `-t` or `--testNamePattern` to
filter by test name. The `--run` flag does not exist in vitest CLI. Config uses
`pool: "threads"` to reduce orphaned process risk.

If system becomes slow, check for orphaned processes with
`ps aux | grep vitest | grep -v grep` and kill them with `pkill -9 -f "vitest"`.

## What to Avoid

Don't test implementation details like how many times a helper function is called. Test
the outcome instead. Don't write brittle assertions that match every field when you only
care about a few - use `toMatchObject()`. Don't rely on timing with sleep() - use proper
async utilities like `waitFor()`.

Avoid testing stable deployment configuration. If an environment variable must be
present for the app to run at all, that's not a runtime test case. Test how your code
handles runtime conditions like invalid user input, not deployment setup.

Keep test output clean by mocking console for tests that trigger expected errors. Use
test-specific log levels. Don't log validation errors to console - return error objects
instead.

## Clean Test Output

Silence expected errors to keep output clean:

```typescript
it("handles missing required field", () => {
  const consoleSpy = vi.spyOn(console, "error").mockImplementation();

  const result = validateInput({});
  expect(result.error).toContain("Missing required field");

  consoleSpy.mockRestore();
});

// Or set LOG_LEVEL for all tests
beforeAll(() => {
  process.env.LOG_LEVEL = "silent";
});
```

## HTTP Status Codes

Use appropriate status codes: 400-level for client errors (bad input, auth failures),
500-level for server errors (unexpected problems, upstream failures). Use 503 Service
Unavailable for configuration issues, not 500 Internal Server Error.

## Coverage Goals

Target 90% line coverage and 85% branch coverage. Prioritize user-facing features,
business logic, error handling, and data transformations. Don't chase 100% - type
definitions, simple getters, framework boilerplate, and obvious pass-through code are
low priority.

## Key Principles Summary

Test behavior, not configuration. Test for success first, then error cases. Minimize
mocking of your own code - use one global PGlite mock with zero local mocks. Write
meaningful tests, not coverage theater. Keep tests isolated and independent. Maintain
clean output so real issues are visible. Use descriptive names that document behavior.
Test one thing per test for easy diagnosis. Integration tests prevent production bugs.

Tests are confidence. Good tests let you refactor fearlessly, catch bugs before
production, and document expected behavior. That's what we optimize for.
