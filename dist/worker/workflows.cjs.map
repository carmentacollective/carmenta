{
  "version": 3,
  "sources": ["../../worker/workflows/index.ts", "../../worker/workflows/agent-job.ts", "../../worker/workflows/background-response.ts", "../../worker/workflows/import-librarian-job.ts"],
  "sourcesContent": ["/**\n * Temporal Workflows - Agent orchestration logic\n *\n * Workflows are deterministic functions that orchestrate activities.\n * They survive crashes and can run for days/weeks/months.\n */\n\nexport * from \"./agent-job\";\nexport * from \"./background-response\";\nexport * from \"./import-librarian-job\";\n", "/**\n * Agent Job Workflow\n *\n * Executes a scheduled job using the employee agent with streaming to Redis.\n * Allows users to \"tap in\" and watch the agent work in real-time.\n *\n * Flow:\n * 1. Load job context (prompt, memory, user info)\n * 2. Create job run record with \"running\" status\n * 3. Generate streamId and save to run record (so UI can connect immediately)\n * 4. Execute streaming employee (streams to Redis under that streamId)\n * 5. Finalize run with results\n */\n\nimport { proxyActivities, ApplicationFailure } from \"@temporalio/workflow\";\nimport type * as activities from \"../activities\";\n\n/**\n * Extract the root cause message from Temporal failures.\n *\n * Temporal wraps activity errors in ActivityFailure, which causes\n * the message to become generic \"Activity task failed\". The actual\n * error is buried in the cause chain. This function digs it out.\n */\nfunction extractRootCauseMessage(error: unknown): string {\n    if (!(error instanceof Error)) {\n        return String(error);\n    }\n\n    // Walk the cause chain to find the deepest error message\n    let current: Error | undefined = error;\n    let deepestMessage = error.message;\n\n    while (current?.cause instanceof Error) {\n        current = current.cause;\n        if (current.message) {\n            deepestMessage = current.message;\n        }\n    }\n\n    // ApplicationFailure has details array that may contain more info\n    if (\n        error instanceof ApplicationFailure &&\n        error.details &&\n        error.details.length > 0\n    ) {\n        const details = error.details[0];\n        if (typeof details === \"string\") {\n            return details;\n        }\n    }\n\n    return deepestMessage;\n}\n\n/**\n * Extract the root cause stack from Temporal failures.\n */\nfunction extractRootCauseStack(error: unknown): string | undefined {\n    if (!(error instanceof Error)) {\n        return undefined;\n    }\n\n    // Walk the cause chain to find the deepest stack\n    let current: Error | undefined = error;\n    let deepestStack = error.stack;\n\n    while (current?.cause instanceof Error) {\n        current = current.cause;\n        if (current.stack) {\n            deepestStack = current.stack;\n        }\n    }\n\n    return deepestStack;\n}\n\nconst {\n    loadFullJobContext,\n    createJobRun,\n    generateJobStreamId,\n    executeStreamingEmployee,\n    updateJobRunStreamId,\n    finalizeJobRun,\n    clearJobRunStreamId,\n} = proxyActivities<typeof activities>({\n    startToCloseTimeout: \"10 minutes\", // Longer timeout for tool-using agents\n    retry: {\n        maximumAttempts: 3,\n        backoffCoefficient: 2,\n    },\n});\n\nexport interface AgentJobInput {\n    jobId: string;\n}\n\nexport interface AgentJobResult {\n    success: boolean;\n    summary: string;\n    runId: string;\n}\n\n/**\n * Main workflow - loads job context, executes streaming employee, records result\n */\nexport async function agentJobWorkflow(input: AgentJobInput): Promise<AgentJobResult> {\n    const { jobId } = input;\n\n    // Load context first so we have userId for error recording if needed\n    const context = await loadFullJobContext(jobId);\n\n    // Create run record immediately so UI can show \"running\" state\n    const runId = await createJobRun(jobId);\n\n    // Generate streamId and save to DB BEFORE execution\n    // This allows users to \"tap in\" as soon as the job starts\n    const streamId = await generateJobStreamId(jobId);\n    await updateJobRunStreamId(runId, streamId);\n\n    try {\n        // Execute streaming employee - streams to Redis under streamId\n        const result = await executeStreamingEmployee(context, streamId);\n\n        // Finalize with results (this clears streamId too)\n        await finalizeJobRun(runId, jobId, context.userId, result);\n\n        return {\n            success: result.success,\n            summary: result.summary,\n            runId,\n        };\n    } catch (error) {\n        // Extract the ACTUAL error from Temporal's ActivityFailure wrapper\n        // Temporal wraps errors, hiding the real message. Dig it out.\n        const errorMessage = extractRootCauseMessage(error);\n        const errorStack = extractRootCauseStack(error);\n\n        // Extract error code - check both wrapped and root cause\n        const errorCode =\n            (error as { code?: string })?.code ??\n            ((error as Error)?.cause as { code?: string })?.code ??\n            \"WORKFLOW_ACTIVITY_FAILED\";\n\n        const failedResult = {\n            success: false,\n            summary: `Failed: ${errorMessage}`,\n            toolCallsExecuted: 0,\n            notifications: [],\n            updatedMemory: context.memory,\n            // Observability fields for debugging\n            errorDetails: {\n                message: errorMessage,\n                code: errorCode,\n                stack: errorStack,\n                context: {\n                    jobId,\n                    runId,\n                    failedAt: new Date().toISOString(),\n                    failurePoint: \"workflow_catch\",\n                    // Include original wrapper message for debugging\n                    temporalMessage: error instanceof Error ? error.message : undefined,\n                },\n            },\n        };\n\n        // Try to finalize the failure, but don't mask the original error\n        try {\n            await finalizeJobRun(runId, jobId, context.userId, failedResult);\n        } catch (finalizationError) {\n            // Finalization failed - activity will capture error in Sentry\n            // Clear stream ID to prevent UI showing stale \"in progress\" state\n            await clearJobRunStreamId(runId).catch(() => {\n                // Double failure - logged in activity, workflow continues with original error\n            });\n        }\n\n        throw error;\n    }\n}\n", "/**\n * Background Response Workflow\n *\n * Orchestrates LLM generation in the background for durable execution.\n * Work survives browser close, deploys, and connection drops.\n *\n * Steps:\n * 1. Load connection context from database\n * 2. Generate response (streams to Redis in real-time)\n * 3. Save response to database\n * 4. Update connection status\n */\n\nimport { proxyActivities, ApplicationFailure } from \"@temporalio/workflow\";\nimport type * as backgroundActivities from \"../activities/background-response\";\n\n/**\n * Extract the root cause message from Temporal failures.\n * Same as agent-job.ts - duplicated because workflows can't share code.\n */\nfunction extractRootCauseMessage(error: unknown): string {\n    if (!(error instanceof Error)) {\n        return String(error);\n    }\n\n    let current: Error | undefined = error;\n    let deepestMessage = error.message;\n\n    while (current?.cause instanceof Error) {\n        current = current.cause;\n        if (current.message) {\n            deepestMessage = current.message;\n        }\n    }\n\n    if (\n        error instanceof ApplicationFailure &&\n        error.details &&\n        error.details.length > 0\n    ) {\n        const details = error.details[0];\n        if (typeof details === \"string\") {\n            return details;\n        }\n    }\n\n    return deepestMessage;\n}\n\nconst {\n    loadConnectionContext,\n    generateBackgroundResponse,\n    saveBackgroundResponse,\n    updateConnectionStatus,\n} = proxyActivities<typeof backgroundActivities>({\n    startToCloseTimeout: \"10 minutes\", // Generous for deep research\n    retry: {\n        maximumAttempts: 3,\n        backoffCoefficient: 2,\n    },\n});\n\nexport interface BackgroundResponseInput {\n    connectionId: number;\n    userId: string;\n    streamId: string;\n    modelId: string;\n    temperature: number;\n    reasoning: {\n        enabled: boolean;\n        effort?: \"high\" | \"medium\" | \"low\" | \"none\";\n        maxTokens?: number;\n    };\n}\n\nexport interface BackgroundResponseResult {\n    success: boolean;\n    partCount: number;\n}\n\n/**\n * Main workflow - orchestrates background response generation\n */\nexport async function backgroundResponseWorkflow(\n    input: BackgroundResponseInput\n): Promise<BackgroundResponseResult> {\n    const { connectionId, streamId } = input;\n\n    try {\n        // Step 1: Load connection context\n        const context = await loadConnectionContext(input);\n\n        // Step 2: Generate response (streams to Redis)\n        const result = await generateBackgroundResponse(input, context);\n\n        // Step 3: Save to database\n        await saveBackgroundResponse(connectionId, streamId, result.parts);\n\n        // Step 4: Update status to completed\n        await updateConnectionStatus(connectionId, \"completed\");\n\n        return {\n            success: true,\n            partCount: result.parts.length,\n        };\n    } catch (error) {\n        // Extract the ACTUAL error from Temporal's ActivityFailure wrapper\n        const rootCauseMessage = extractRootCauseMessage(error);\n\n        // Mark as failed on any error\n        // The activity will have already been retried by Temporal\n        try {\n            await updateConnectionStatus(connectionId, \"failed\");\n        } catch {\n            // Status update failed - activity captures error in Sentry, workflow proceeds\n        }\n\n        // Throw with the REAL error message, not the generic wrapper\n        throw ApplicationFailure.nonRetryable(\n            rootCauseMessage,\n            \"BackgroundResponseFailed\"\n        );\n    }\n}\n", "/**\n * Import Librarian Job Workflow\n *\n * Orchestrates knowledge extraction from imported conversations.\n * Processes conversations in batches with progress updates.\n *\n * Durable execution - survives server restarts and handles retries.\n */\n\nimport { proxyActivities, ApplicationFailure } from \"@temporalio/workflow\";\nimport type * as activities from \"../activities/import-librarian\";\n\n// Proxy activities with retry configuration\nconst {\n    loadImportLibrarianContext,\n    processConversationBatch,\n    updateJobProgress,\n    finalizeImportLibrarianJob,\n} = proxyActivities<typeof activities>({\n    startToCloseTimeout: \"10 minutes\",\n    retry: {\n        maximumAttempts: 3,\n        backoffCoefficient: 2,\n    },\n});\n\nconst BATCH_SIZE = 10;\n\nexport interface ImportLibrarianJobInput {\n    jobId: string;\n    userId: string;\n    connectionIds?: number[];\n}\n\nexport interface ImportLibrarianJobResult {\n    success: boolean;\n    totalProcessed: number;\n    totalExtracted: number;\n    errors: string[];\n}\n\n/**\n * Main import librarian workflow\n *\n * 1. Load context (user, connections to process)\n * 2. Process conversations in batches\n * 3. Update progress after each batch\n * 4. Finalize job status\n */\nexport async function importLibrarianJobWorkflow(\n    input: ImportLibrarianJobInput\n): Promise<ImportLibrarianJobResult> {\n    const { jobId } = input;\n    let totalProcessed = 0;\n    let totalExtracted = 0;\n    const allErrors: string[] = [];\n\n    try {\n        // Step 1: Load context\n        const context = await loadImportLibrarianContext(input);\n\n        if (context.connectionIds.length === 0) {\n            // Nothing to process\n            await finalizeImportLibrarianJob(jobId, true);\n            return {\n                success: true,\n                totalProcessed: 0,\n                totalExtracted: 0,\n                errors: [],\n            };\n        }\n\n        // Step 2: Process in batches\n        for (let i = 0; i < context.connectionIds.length; i += BATCH_SIZE) {\n            const batch = context.connectionIds.slice(i, i + BATCH_SIZE);\n\n            // Process batch\n            const result = await processConversationBatch(context, batch);\n\n            totalProcessed += result.processedCount;\n            totalExtracted += result.extractedCount;\n            allErrors.push(...result.errors);\n\n            // Update progress\n            await updateJobProgress(jobId, totalProcessed, totalExtracted);\n        }\n\n        // Step 3: Finalize as success\n        await finalizeImportLibrarianJob(jobId, true);\n\n        return {\n            success: true,\n            totalProcessed,\n            totalExtracted,\n            errors: allErrors,\n        };\n    } catch (error) {\n        // Extract actual error message from Temporal's wrapper\n        const errorMessage = extractRootCauseMessage(error);\n\n        // Mark job as failed\n        await finalizeImportLibrarianJob(jobId, false, errorMessage).catch(() => {\n            // Ignore finalization errors - main error is more important\n        });\n\n        // Throw non-retryable failure so Temporal doesn't keep retrying\n        throw ApplicationFailure.nonRetryable(errorMessage, \"ImportLibrarianJobFailed\");\n    }\n}\n\n/**\n * Extract the actual error message from Temporal's error wrapper chain\n */\nfunction extractRootCauseMessage(error: unknown): string {\n    if (!(error instanceof Error)) return String(error);\n\n    // Walk the cause chain to find the deepest error\n    let current: Error | undefined = error;\n    let deepestMessage = error.message;\n\n    while (current?.cause instanceof Error) {\n        current = current.cause;\n        if (current.message) {\n            deepestMessage = current.message;\n        }\n    }\n\n    return deepestMessage;\n}\n"],
  "mappings": "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",
  "names": ["import_workflow", "extractRootCauseMessage", "import_workflow", "extractRootCauseMessage"]
}
